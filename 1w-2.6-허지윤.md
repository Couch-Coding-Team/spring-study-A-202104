## 2.6 쿼리 메서드 기능과 @Query

### 1. 쿼리 메서드란?

- 메서드의 이름 자체가 쿼리의 구문으로 처리되는 기능
- docs: [link](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods)

[2. 쿼리 메서드 종류](https://www.notion.so/8653186f8c01476594878d180a5aa69a)

### Ex 1) Between 을 사용한다고 했을 때

- **SQL 문 사용시**

```sql
SELECT * FROM spring.tbl_memo
WHERE mno >= 5 AND mno <= 9
ORDER BY mno DESC
```

- **Spring Data JPA 사용시**

👇 MemoRepository 인터페이스에 추가

```java
package org.zerock.ex2.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.zerock.ex2.entity.Memo;

import java.util.List;

public interface MemoRepository extends JpaRepository<Memo, Long>{
    List<Memo> findByMnoBetweenOrderByMnoDesc(Long from, Long to);
}
```

👇 MemoRepositoryTests 클래스에 추가

```java
package org.zerock.ex2.repository;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.zerock.ex2.entity.Memo;

import java.util.List;
import java.util.Optional;
import java.util.stream.IntStream;

@SpringBootTest
public class MemoRepositoryTests {
    @Autowired
    MemoRepository memoRepository;

    @Test
    public void testQueryMethods(){
        List<Memo> list = memoRepository.findByMnoBetweenOrderByMnoDesc(5L, 9L);
        for (Memo memo : list){
            System.out.println(memo);
        }
    }
}
```

- **결과**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3b0abdf-f18b-49a6-b1e4-f70d31193fbc/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3b0abdf-f18b-49a6-b1e4-f70d31193fbc/Untitled.png)

### Ex 2) 쿼리 메서드 + Pageable

### 왜 필요한가?

- Ex 1) 에서와 같이 'OrderBy' 가 들어가면 메서드 이름이 길어져서 혼동하기가 쉬워짐. 그래서 Pageable 파라미터를 같이 결합해서 좀 더 간략한 메서드를 생성하기 위해서 필요하다.

👇 MemoRepository 인터페이스에 추가

```java
package org.zerock.ex2.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.JpaRepository;
import org.zerock.ex2.entity.Memo;

import java.awt.print.Pageable;
import java.util.List;

public interface MemoRepository extends JpaRepository<Memo, Long>{
    //    길고 헷갈림
    List<Memo> findByMnoBetweenOrderByMnoDesc(Long from, Long to);

    //    ⭐️ 짧음
    Page<Memo> findByMnoBetween(Long from, Long to, Pageable pageable);
}
```

👇 MemoRepositoryTests 클래스에 추가

```java
@Test
public void testQueryMethodWithPageable(){
    Pageable pageable = PageRequest.of(0, 4, Sort.by("mno").descending());
    Page<Memo> result = memoRepository.findByMnoBetween(1L, 7L, pageable);
    result.get().forEach(memo -> System.out.println(memo));
}
```

- **결과**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae1be481-0020-40f6-ba95-cb3ce9226cb2/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae1be481-0020-40f6-ba95-cb3ce9226cb2/Untitled.png)

### Ex 3) deleteBy로 시작하는 삭제처리

👇 MemoRepository 인터페이스에 추가

```java
import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.JpaRepository;
import org.zerock.ex2.entity.Memo;

import org.springframework.data.domain.Pageable;
import java.util.List;

public interface MemoRepository extends JpaRepository<Memo, Long>{

    //    delete
    void deleteMemoByMnoLessThan(Long num);
}
```

👇 MemoRepositoryTests 클래스에 추가

```java
		@Commit
    @Transactional
    @Test
    public void testDeleteQueryMethods(){
        memoRepository.deleteMemoByMnoLessThan(2L);
    }
```

@Transactional 어노테이션 필요한 이유?

- deleteBy..의 경우 우선 'select'문으로 해당 엔티티 객체들을 가져오는 작업과 각 엔티티를 삭제하는 작업이 같이 이루어지기 때문.



@Commit 어노테이션 필요한 이유?

- 최종 결과를 커밋하기 위해서 사용. 이를 적용하지 않으면 deleteBy.. 가 롤백 처리되어서 결과가 반영되지 않음.

그런데 deleteBy 는 실제 개발에서 많이 사용되지 않는다고 함. 왜? SQL 처럼 한번에 삭제가 이루어지는 것이 아니라 각 엔티티 객체를 하나씩 삭제하기 때문!
